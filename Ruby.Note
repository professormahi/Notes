links:
	http://www.codecademy.com/


Mathematics:
	all *, +, -, %, **(means power), /
	
Operators:
	<=>
		first <=> second
		Returns 0 if first and second are equal, 1 if first is greater, -1 if second is bigger
	
	||=
		Will assign if last value is null		

Input/Output:
	Standard output:
		puts
		
		print
		
	Standard input:
		gets
			.chomp
			
String:
	.upcase
		Result the uppercase of input
		
	.downcase
		Result the lowercase of the input
		
	.capitalize
		Result the capitalize of input
		e.g. mahdi -> Mahdi
	
	.capitalize!
		Save the capitalize in input
		
	.include? "to_search"
		Returns true if the input has to_search
		
	.gsub!(to_replace, replace_with)
		Global substitution of input
		e.g. 'salam'.gsub!(/s/, 'th') --> thalam
	
	.split("to_split_with")
		Split the input with to_split_with
		
	<< sth
		Add "sth" to the string
		
	NOTE:
		For stings +, and << are the same
	
Numbers:
	.next
		Give the next number
		
Convertings and types:
	Integer():
		Convert to integer
		
	.to_s
		Convert to string
		
	.to_sym
		Convert to symbol
	
	.to_a
		Convert to array
	
	.intern
		Just like .to_sym
		
	.is_a? type
		Returns true if the variables is from type "type"
		
	.object_id
		Returns id of an object, Ruby understand equaling from this ids
		
	.respond_to? :method_name
		Returns true if an object can respond to the method
		
Control flows and loops:
	if:
		if condition
			# Commands
		elsif condition
			# Commands
		else
			# Commands
		end
		
		NOTE: Another type of if
			expression if condition
			
		NOTE: Another
			condition ? if_true_command : if_false_command
		
	unless: (unless means if not)
		unless condition
			# Commands
		else
			# Commands
		end
		
		NOTE: Another type
			expression unless condition
		
	while:
		while condition do
			# Commands
		end
		
	until: (same as while not)
		until condition
			# Commands
		end
	
	for:
		for foo in foos
			# Commands
		end
		
		NOTE: 
			(for i in 1...16) and (for i in 1..15) are same, Means that .. the last is included
			
	NOTE:			
		{ #Commands } --> Means
			do
				# Commands
			end
	
	loop: (Infinite loop)
		loop do
		
		end
		
	break:
		break condition
		
	next:
		next condition
		
	.times:
		n.times { #Commands }
		This command execute Commands n times
		
	case:
		case to_have_case_on
		when first
			# Commands
		end
		when second
			# Commands
		end
		.
		.
		.
		else
			# Commands
		end
		
	from.upto(till)
		Do sth from "from" till "till"
		
	from.downto(till)
		Just like upto but the oposite
		

Arrays:
	[]
	.each { |foo| # Commands }
	
	.each do |foo|	
		# Commands
	end
	
	.reverse!
		Reverse the array(, or stings)
	
	.sort!
		Sort the array
		Usage:
			{ |f, s| f <=>s }
	
	.push sth
		Push sth to the array
		
	.zip array
		Make hash using the input and the array
		
	<< value
		Add a "value" to the array
	
Hashes: (Map, Dictionary)
	{
		key => value,
		key => value,
		.
		.
		.
	}
	
	Hash.new (or Hash.new(default_value))
		Creates a new hash
		
	.default = val
		Set default value	
		
	.sort_by {|k, v| to_sort_with}
		Sort hash with to_sort_with
		
	.select {|k, v| condition}
		Select with that condition
	
	.each_value { |v| do_sth_on_v }
		Do do_sth_on_v on v		
	
	.each_key { |k| do_sth_on_k }
		Do do_sth_on_k on k
		
	.delete
		Delete a hash member
			
	1.9 standard:
		={
			key: val,
			key: val,
		} --> keys are symbols without ":"
	
	NOTE:
		Hashes with symbol keys are faster :D

Methods:
	def method_name(args):
		# Commands
	end	
	
	NOTE:	
		()'s are note require
		
	NOTE:
		def some_method(first, *second); Can be used like this some_method(first, second1, second2, ...)
		Using * means many args as an array
	
	NOTE:
		Ruby Accept default values
		
	NOTE:
		You can use implicit return instead of return statement
		e.g.
			def (a, b)
				a+b
			end
		
Symbols:
	:name

Benchmark:
	require 'benchmark'
	usage:
		Benchmark.realtime do
			# Commands
		end
